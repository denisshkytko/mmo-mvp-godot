# Технический долг (обзор)

Ниже перечислены основные зоны потенциального технического долга. Для каждого пункта указаны примеры файлов/строк, категория, уровень риска и рекомендованный подход к исправлению.

## 1) Автoload AppState знает о сценах и управляет UI-навигацией
- **Статус:** Resolved — навигация вынесена в `FlowRouter`, AppState больше не содержит путей сцен (методы оставлены как deprecated прокси).【F:core/managers/flow_router.gd†L1-L21】【F:core/managers/app_state.gd†L58-L77】

## 2) Жёсткие зависимости между экранами и прямые обращения к глобальному состоянию
- **Файлы и примерные строки:**
  - `ui/flow/login_ui.gd` (стр. 20–38).【F:ui/flow/login_ui.gd†L20-L38】
  - `ui/flow/login_hud.gd` (стр. 24–38).【F:ui/flow/login_hud.gd†L24-L38】
  - `ui/flow/character_select_hud.gd` (стр. 29–68).【F:ui/flow/character_select_hud.gd†L29-L68】
  - `ui/flow/character_select_ui.gd` (стр. 12–26).【F:ui/flow/character_select_ui.gd†L12-L26】
- **Категория:** ui / ux
- **Уровень риска:** средний
- **Почему это проблема:** экраны напрямую вызывают методы AppState, включая переходы между сценами. UI становится тесно связанным с глобальным состоянием и логикой переходов, что затрудняет модификации потока и тестирование отдельных экранов.
- **Рекомендованный подход:** внедрить слой посредника (например, UI-координатор/контроллер потока), через который UI запрашивает действия, а глобальные синглтоны остаются «тонкими».

## 3) Дублирование логики логина в двух скриптах
- **Файлы и примерные строки:**
  - `ui/flow/login_ui.gd` (стр. 1–40).【F:ui/flow/login_ui.gd†L1-L40】
  - `ui/flow/login_hud.gd` (стр. 1–39).【F:ui/flow/login_hud.gd†L1-L39】
- **Категория:** масштабируемость
- **Уровень риска:** низкий
- **Почему это проблема:** одинаковая логика логина поддерживается в двух местах; при изменениях можно забыть обновить вторую реализацию, что приведёт к расхождению поведения.
- **Рекомендованный подход:** выделить общую логику (например, в утилиту/компонент) и использовать её в обоих UI.

## 4) Магические строки и нецентрализованная схема состояния персонажа
- **Файлы и примерные строки:**
  - `core/managers/app_state.gd` (стр. 68–95) — набор полей в словаре сохранения.【F:core/managers/app_state.gd†L68-L95】
  - `game/characters/player/player.gd` (стр. 371–441) — чтение/запись полей в словарь состояния.【F:game/characters/player/player.gd†L371-L441】
- **Категория:** архитектура
- **Уровень риска:** средний
- **Почему это проблема:** структура состояния персонажа задаётся «на местах» строковыми ключами ("level", "xp", "inventory" и т.д.) без централизованной схемы. Это повышает риск несогласованности и ошибок при расширении данных.
- **Рекомендованный подход:** определить централизованную схему/контракт данных состояния (например, отдельный ресурс/структуру с полями и миграциями) и использовать её во всех местах записи/чтения.

## 5) Отсутствие централизованной state-machine для глобального состояния игры
- **Статус:** Resolved — AppState содержит явные состояния и правила переходов (`FlowState`, `can_transition`, `set_state`).【F:core/managers/app_state.gd†L5-L56】

## 6) Сохранения без версионирования и атомарной записи
- **Статус:** Resolved — запись выполняется атомарно через `.tmp` → rename и создаётся `.bak`. Версионирование схемы всё ещё отсутствует, но проблема с атомарностью устранена.【F:core/save/save_system.gd†L21-L64】

## 7) Потенциальные ошибки при отсутствии автoload/узлов
- **Файлы и примерные строки:**
  - `ui/flow/character_select_hud.gd` (стр. 29–68) — прямой доступ к `AppState` без проверки наличия автoload.【F:ui/flow/character_select_hud.gd†L29-L68】
  - `ui/flow/character_select_ui.gd` (стр. 12–26) — прямой вызов методов `AppState` без fallback.【F:ui/flow/character_select_ui.gd†L12-L26】
- **Категория:** bug risk
- **Уровень риска:** средний
- **Почему это проблема:** при сбое загрузки автoload или некорректной инициализации сцены такие обращения могут привести к ошибкам и пустым экранам.
- **Рекомендованный подход:** централизовать проверки доступности синглтонов, а UI связывать с интерфейсом/сервисом, который сам гарантирует корректное состояние.

## 8) Признаки проблем с порядком инициализации (DataDB в UI)
- **Файлы и примерные строки:** `ui/game/hud/inventory_hud.gd` (стр. 768–774) — повторная попытка из-за потенциальной неготовности DataDB.【F:ui/game/hud/inventory_hud.gd†L768-L774】
- **Категория:** архитектура
- **Уровень риска:** средний
- **Почему это проблема:** UI вынужден самостоятельно «ретраить» доступ к данным, что указывает на слабый контроль порядка инициализации и зависимостей между слоями.
- **Рекомендованный подход:** обеспечить явную инициализацию зависимостей (например, событие готовности DataDB), либо загружать UI только после готовности данных.

---

# Автоматические проверки

- **Done:** headless smoke-раннер `res://tests/run_headless.gd`.【F:tests/run_headless.gd†L1-L188】
- **Next (опционально):** расширить smoke-проверки до боевого цикла/инвентаря.

# На что обратить внимание в первую очередь

1. **Жёсткая связность UI и глобального состояния** (средний риск, тормозит развитие UI и флоу).【F:ui/flow/login_ui.gd†L20-L38】【F:ui/flow/character_select_hud.gd†L29-L68】
2. **Магические строки и схема состояния персонажа без централизованного контракта** (средний риск ошибок при расширении данных).【F:core/managers/app_state.gd†L68-L95】【F:game/characters/player/player.gd†L371-L441】
3. **Проблемы инициализации DataDB, ретраи в UI** (средний риск скрытых ошибок).【F:ui/game/hud/inventory_hud.gd†L768-L774】
4. **Дублирование логики логина** (низкий риск, но увеличивает поддержку).【F:ui/flow/login_ui.gd†L1-L40】【F:ui/flow/login_hud.gd†L1-L39】
