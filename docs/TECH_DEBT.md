# Технический долг (обзор)

Ниже перечислены основные зоны потенциального технического долга. Для каждого пункта указаны примеры файлов/строк, категория, уровень риска и рекомендованный подход к исправлению.

## 1) Автoload AppState знает о сценах и управляет UI-навигацией
- **Файлы и примерные строки:** `core/managers/app_state.gd` (стр. 10–20).【F:core/managers/app_state.gd†L10-L20】
- **Категория:** архитектура
- **Уровень риска:** средний
- **Почему это проблема:** глобальный синглтон знает о конкретных UI/игровых сценах и управляет переходами. Это жёстко связывает бизнес-логику и представление, усложняет тестирование и усложняет смену UI-потока.
- **Рекомендованный подход:** вынести навигацию из автoload в отдельный слой/контроллер потока (например, сценовый роутер), а AppState оставить только для состояния/данных.

## 2) Жёсткие зависимости между экранами и прямые обращения к глобальному состоянию
- **Файлы и примерные строки:**
  - `ui/flow/login_ui.gd` (стр. 20–38).【F:ui/flow/login_ui.gd†L20-L38】
  - `ui/flow/login_hud.gd` (стр. 24–38).【F:ui/flow/login_hud.gd†L24-L38】
  - `ui/flow/character_select_hud.gd` (стр. 29–68).【F:ui/flow/character_select_hud.gd†L29-L68】
  - `ui/flow/character_select_ui.gd` (стр. 12–26).【F:ui/flow/character_select_ui.gd†L12-L26】
- **Категория:** ui / ux
- **Уровень риска:** средний
- **Почему это проблема:** экраны напрямую вызывают методы AppState, включая переходы между сценами. UI становится тесно связанным с глобальным состоянием и логикой переходов, что затрудняет модификации потока и тестирование отдельных экранов.
- **Рекомендованный подход:** внедрить слой посредника (например, UI-координатор/контроллер потока), через который UI запрашивает действия, а глобальные синглтоны остаются «тонкими».

## 3) Дублирование логики логина в двух скриптах
- **Файлы и примерные строки:**
  - `ui/flow/login_ui.gd` (стр. 1–40).【F:ui/flow/login_ui.gd†L1-L40】
  - `ui/flow/login_hud.gd` (стр. 1–39).【F:ui/flow/login_hud.gd†L1-L39】
- **Категория:** масштабируемость
- **Уровень риска:** низкий
- **Почему это проблема:** одинаковая логика логина поддерживается в двух местах; при изменениях можно забыть обновить вторую реализацию, что приведёт к расхождению поведения.
- **Рекомендованный подход:** выделить общую логику (например, в утилиту/компонент) и использовать её в обоих UI.

## 4) Магические строки и нецентрализованная схема состояния персонажа
- **Файлы и примерные строки:**
  - `core/managers/app_state.gd` (стр. 68–95) — набор полей в словаре сохранения.【F:core/managers/app_state.gd†L68-L95】
  - `game/characters/player/player.gd` (стр. 371–441) — чтение/запись полей в словарь состояния.【F:game/characters/player/player.gd†L371-L441】
- **Категория:** архитектура
- **Уровень риска:** средний
- **Почему это проблема:** структура состояния персонажа задаётся «на местах» строковыми ключами ("level", "xp", "inventory" и т.д.) без централизованной схемы. Это повышает риск несогласованности и ошибок при расширении данных.
- **Рекомендованный подход:** определить централизованную схему/контракт данных состояния (например, отдельный ресурс/структуру с полями и миграциями) и использовать её во всех местах записи/чтения.

## 5) Отсутствие централизованной state-machine для глобального состояния игры
- **Файлы и примерные строки:** `core/managers/app_state.gd` (стр. 10–35) — состояние авторизации и переходы сцен происходят без единой state-machine.【F:core/managers/app_state.gd†L10-L35】
- **Категория:** архитектура
- **Уровень риска:** средний
- **Почему это проблема:** переходы между состояниями (логин → выбор персонажа → мир) управляются напрямую через смену сцен и флаги, что усложняет поддержку сложных сценариев (повторы, отмены, ошибки авторизации).
- **Рекомендованный подход:** ввести централизованную state-machine (например, с явными состояниями и переходами), чтобы управлять логикой входа/выхода и переходами UI.

## 6) Сохранения без версионирования и атомарной записи
- **Файлы и примерные строки:** `core/save/save_system.gd` (стр. 21–75) и (стр. 77–109).【F:core/save/save_system.gd†L21-L109】
- **Категория:** bug risk
- **Уровень риска:** высокий
- **Почему это проблема:** отсутствует версионирование сейвов и миграции, а запись происходит напрямую (без временных файлов/атомарного rename). При сбое можно получить повреждённые данные или рассинхронизацию между `index.json` и файлами персонажей.
- **Рекомендованный подход:** добавить версионирование схемы сейва, миграции и атомарную запись (write temp → rename), а также резервные копии/валидацию целостности.

## 7) Потенциальные ошибки при отсутствии автoload/узлов
- **Файлы и примерные строки:**
  - `ui/flow/character_select_hud.gd` (стр. 29–68) — прямой доступ к `AppState` без проверки наличия автoload.【F:ui/flow/character_select_hud.gd†L29-L68】
  - `ui/flow/character_select_ui.gd` (стр. 12–26) — прямой вызов методов `AppState` без fallback.【F:ui/flow/character_select_ui.gd†L12-L26】
- **Категория:** bug risk
- **Уровень риска:** средний
- **Почему это проблема:** при сбое загрузки автoload или некорректной инициализации сцены такие обращения могут привести к ошибкам и пустым экранам.
- **Рекомендованный подход:** централизовать проверки доступности синглтонов, а UI связывать с интерфейсом/сервисом, который сам гарантирует корректное состояние.

## 8) Признаки проблем с порядком инициализации (DataDB в UI)
- **Файлы и примерные строки:** `ui/game/hud/inventory_hud.gd` (стр. 768–774) — повторная попытка из-за потенциальной неготовности DataDB.【F:ui/game/hud/inventory_hud.gd†L768-L774】
- **Категория:** архитектура
- **Уровень риска:** средний
- **Почему это проблема:** UI вынужден самостоятельно «ретраить» доступ к данным, что указывает на слабый контроль порядка инициализации и зависимостей между слоями.
- **Рекомендованный подход:** обеспечить явную инициализацию зависимостей (например, событие готовности DataDB), либо загружать UI только после готовности данных.

---

# На что обратить внимание в первую очередь

1. **Сохранения без версионирования и атомарной записи** (высокий риск потери данных).【F:core/save/save_system.gd†L21-L109】
2. **Жёсткая связность UI и глобального состояния** (средний риск, тормозит развитие UI и флоу).【F:ui/flow/login_ui.gd†L20-L38】【F:ui/flow/character_select_hud.gd†L29-L68】
3. **AppState управляет сценами напрямую** (средний риск, архитектурная связанность).【F:core/managers/app_state.gd†L10-L20】
4. **Магические строки и схема состояния персонажа без централизованного контракта** (средний риск ошибок при расширении данных).【F:core/managers/app_state.gd†L68-L95】【F:game/characters/player/player.gd†L371-L441】
5. **Проблемы инициализации DataDB, ретраи в UI** (средний риск скрытых ошибок).【F:ui/game/hud/inventory_hud.gd†L768-L774】
6. **Дублирование логики логина** (низкий риск, но увеличивает поддержку).【F:ui/flow/login_ui.gd†L1-L40】【F:ui/flow/login_hud.gd†L1-L39】
